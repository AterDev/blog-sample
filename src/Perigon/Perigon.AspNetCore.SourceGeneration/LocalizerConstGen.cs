using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Perigon.AspNetCore.SourceGeneration;

[Generator(LanguageNames.CSharp)]
public class LocalizerConstGen : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Step 1: 从 resx 文件中提取数据，按类名去重只取第一个文件
        var resxDataProvider = context
            .AdditionalTextsProvider.Where(static file =>
                file.Path.EndsWith(".resx", StringComparison.OrdinalIgnoreCase)
            )
            .Collect()
            .SelectMany(static (files, cancellationToken) =>
            {
                // 按类名分组，每组只取第一个文件
                return files
                    .GroupBy(f => Path.GetFileName(f.Path).Split('.').FirstOrDefault() ?? "Localizer")
                    .Select(g => (ClassName: g.Key, File: g.First()))
                    .ToImmutableArray();
            })
            .Select(static (item, cancellationToken) =>
            {
                var (className, file) = item;
                var text = file.GetText(cancellationToken)?.ToString();

                if (string.IsNullOrWhiteSpace(text))
                {
                    return new ResxData(className, ImmutableArray<string>.Empty);
                }

                try
                {
                    var doc = XDocument.Parse(text);
                    var keys = doc.Descendants("data")
                        .Select(e => e.Attribute("name")?.Value)
                        .Where(n => !string.IsNullOrWhiteSpace(n))
                        .Distinct()
                        .OrderBy(k => k)
                        .ToImmutableArray();

                    return new ResxData(className, keys!);
                }
                catch
                {
                    return new ResxData(className, ImmutableArray<string>.Empty);
                }
            })
            .Where(static data => data.Keys.Length > 0);

        // Step 2: 查找匹配的 partial class 声明
        var classProvider = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, _) =>
                node is ClassDeclarationSyntax classDecl
                && classDecl.Modifiers.Any(m => m.Text == "partial"),
            transform: static (ctx, _) =>
            {
                var classDecl = (ClassDeclarationSyntax)ctx.Node;
                return new ClassInfo(classDecl.Identifier.Text, GetNamespace(classDecl));
            }
        );

        // Step 3: 合并数据并生成代码
        var combined = resxDataProvider.Collect().Combine(classProvider.Collect());

        context.RegisterSourceOutput(
            combined,
            static (spc, pair) =>
            {
                var (resxList, classList) = pair;

                foreach (var resx in resxList)
                {
                    var matchedClass = classList.FirstOrDefault(c =>
                        c.ClassName.Equals(resx.ClassName, StringComparison.Ordinal)
                    );

                    var ns = matchedClass.Namespace ?? "Share";
                    var source = GenerateSource(resx.ClassName, ns, resx.Keys);

                    spc.AddSource(
                        $"{resx.ClassName}.g.cs",
                        SourceText.From(source, Encoding.UTF8)
                    );
                }
            }
        );
    }

    private static string GenerateSource(string className, string ns, ImmutableArray<string> keys)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine($"public partial class {className}");
        sb.AppendLine("{");

        foreach (var key in keys)
        {
            var valName = key;
            if (int.TryParse(valName, out _))
            {
                valName = $"_{valName}";
            }
            if (valName.Contains('-'))
            {
                valName = valName.Replace('-', '_');
            }
            sb.AppendLine($"    public const string {valName} = \"{key}\";");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GetNamespace(ClassDeclarationSyntax classDecl)
    {
        return classDecl.Parent switch
        {
            BaseNamespaceDeclarationSyntax baseNs => baseNs.Name.ToString(),
            _ => "Share",
        };
    }

    #region 数据结构

    private readonly struct ResxData : IEquatable<ResxData>
    {
        public string ClassName { get; }
        public ImmutableArray<string> Keys { get; }

        public ResxData(string className, ImmutableArray<string> keys)
        {
            ClassName = className;
            Keys = keys;
        }

        public bool Equals(ResxData other)
        {
            return ClassName == other.ClassName && Keys.SequenceEqual(other.Keys);
        }

        public override bool Equals(object obj) => obj is ResxData other && Equals(other);

        public override int GetHashCode()
        {
            var hash = ClassName?.GetHashCode() ?? 0;
            foreach (var key in Keys)
            {
                hash = (hash * 31) + (key?.GetHashCode() ?? 0);
            }
            return hash;
        }
    }

    private readonly struct ClassInfo : IEquatable<ClassInfo>
    {
        public string ClassName { get; }
        public string Namespace { get; }

        public ClassInfo(string className, string ns)
        {
            ClassName = className;
            Namespace = ns;
        }

        public bool Equals(ClassInfo other)
        {
            return ClassName == other.ClassName && Namespace == other.Namespace;
        }

        public override bool Equals(object obj) => obj is ClassInfo other && Equals(other);

        public override int GetHashCode()
        {
            return ((ClassName?.GetHashCode() ?? 0) * 31) + (Namespace?.GetHashCode() ?? 0);
        }
    }

    #endregion
}
